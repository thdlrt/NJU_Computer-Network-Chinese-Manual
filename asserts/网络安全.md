# 网络安全

## 概述

- 分类
  - <img src="./images/image-20230517140759342.png" style="zoom:33%;" />
  - 阻断、窃听、修改、伪装
- 被动攻击：
  - 窃听
    - 明文传输可以直接获取
    - 加密传输还可以分析传输模式等信息
  - 不干扰过程，但是窃取信息
  - 很难能被发现
- 主动攻击：
  - 伪装
  - 修改
  - 阻断服务
  - 很难被阻止但是容易发现
- 安全要求：
  - keyongxing可用性：针对阻断（通讯不能被阻断）
  - 机密性：针对窃听（不能被听懂（可以听））
  - 完整性：针对篡改（不能在无法察觉的前提下修改）
  - 授权性：针对伪装（保证双方的身份正确）

- 模型
  - <img src="./images/image-20230517142105151.png" alt="image-20230517142105151" style="zoom:33%;" />
    - 不能对物理安全做任何假设
    - 加密的**算法**也不是保密的
  - <img src="./images/image-20230517142305926.png" alt="image-20230517142305926" style="zoom:33%;" />
    - 对信息内容加密
    - 增加校验，识别改动
    - 标志，源不能被伪装

## 加密

### 对称密钥

- <img src="./images/image-20230517142617786.png" alt="image-20230517142617786" style="zoom:33%;" />
  - 即使有密钥也很难解码，还需要解码算法
  - 难以被破解
  - 问题：如何实现安全的**密钥传递**
- 只拥有密文：
  - 穷举法：尝试使用所有可能的密钥对密文进行解密。
  - 密码分析：利用加密算法的性质以及对明文和密文的一般特征的了解，试图推断出原始信息或加密密钥。
- **已知明文攻击**：
  - 拥有明**文和相应的密文**。能够分析二者之间的关系，有可能推断出加密密钥或解密其他密文。
- **已选择明文攻击**：
  - 可以选择特定的明文消息并**获取**相应的密文。能够分析加密过程，可能发现漏洞或推导出加密密钥。

#### 传统加密

- 易于破解

##### 凯撒密码

<img src="./images/image-20230517143428412.png" alt="image-20230517143428412" style="zoom:33%;" />

- key只有一位，最多只需要尝试26次

##### 单表密码

<img src="./images/image-20230517143527508.png" alt="image-20230517143527508" style="zoom: 50%;" />

- 将字母乱序对应
- 通过语言学分析（如出现次数）进行破解

##### Vigenere密码

- <img src="./images/image-20230517145530392.png" alt="image-20230517145530392" style="zoom:33%;" />
- <img src="./images/image-20230517145545322.png" alt="image-20230517145545322" style="zoom:33%;" />

##### Rail Fence Cipher

- <img src="./images/image-20230517144042228.png" alt="image-20230517144042228" style="zoom:33%;" />

- 按列书写，转换为行
- key是行数
- 暴力破解

##### Row-Column Cipher

- 在rail的基础上增加列顺序变幻
- <img src="./images/image-20230517144222949.png" alt="image-20230517144222949" style="zoom:33%;" />

#### 现代加密（块加密）

- 计算机可以实现快速暴力破解
- 对称加密使用快加密的方式
- 算法
  - 数据加密标准（Data Encryption Standard，DES）：DES是一种对称密钥块密码，使用56位密钥对64位的明文块进行加密。然而，由于DES的密钥长度较短，已经被认为不够安全，因此在一些应用中已经不再广泛使用。
  - 三重数据加密标准（Triple Data Encryption Standard，TDES）：TDES是对DES的改进和增强版本。它通过对数据应用DES算法三次来提高安全性。TDES可以使用不同的密钥长度（如168位）和操作模式，以提供更高的保护级别。
  - 高级加密标准（Advanced Encryption Standard，AES）：AES是一种广泛采用的对称密钥块密码，被视为DES的替代方案。AES使用可变长度的密钥（如128位、192位或256位），以及不同的加密模式和操作方法，具有较高的安全性和效率。
- <img src="./images/image-20230517144709420.png" alt="image-20230517144709420" style="zoom: 50%;" />

##### DES加密

- <img src="./images/image-20230517150124406.png" alt="image-20230517150124406" style="zoom:33%;" />
  - 选择一个56位的密钥，通过应用**奇偶校验**位生成64位的密钥(将56位的密钥按每个字节的7个位进行分组，形成8个字节，每组统计1的个数，计算得到8位校验码)
  - 将输入的64位明文分成左右两个32位的数据块（L0和R0）。对每个数据块应用**初始置换**表（IP表）进行重排（打乱原先列列的顺序，按照一个固定顺序进行重新排列）
  - 迭代运算（具体运算过程不需要掌握）
    - 迭代运算共有16轮，每轮都使用不同的子密钥。
    - 对于每一轮，进行以下操作：
      - 将前一轮的左数据块（Li-1）赋值给当前轮的右数据块（Ri-1）。
      - 对右数据块进行扩展置换（Expansion Permutation），将32位扩展为48位。
      - 将扩展后的右数据块与当前轮的子密钥进行异或运算。
      - 将异或结果分成8个6位的块，每个块通过S-Box进行替换得到4位的结果。
      - 将替换后的结果合并成一个32位的数据块。
      - 对合并后的数据块进行P-Box置换。
      - 将P-Box置换的结果与前一轮的左数据块进行异或运算，并将结果作为当前轮的左数据块（Li）。
  - 最终置换（Final Permutation）：
    - 将最后一轮迭代后的左右数据块进行交换。
    - 将交换后的左右数据块合并成64位的数据块。
    - 对合并后的数据块应用最终置换表（FP表）进行重排，得到最终的64位密文
- 每轮过程<img src="./images/image-20230517150137744.png" alt="image-20230517150137744" style="zoom:33%;" />
- 只能使用暴力破解$O(2{56}) = O(10^{17}) $keys
  - 随着计算机发展，容易被破解了
  - 淘汰

##### Triple DES

- Uses 3 keys and 3 executions of DES algorithm
- 相当于进行3次DES
  - EEE模式，三次加密
  - EDE模式，加密、解密、加密
- 问题：块太小（64比特）速度太慢

##### *AES

- 可变key长128~256
- 比Triple DES的效率更高
- <img src="./images/image-20230517150713121.png" alt="image-20230517150713121" style="zoom:33%;" />
- 以块（二维数组）的格式进行运算，效率更高
  - State Array
    - 一个矩形数组，由4行和B（等于4）列组成，每个数组条目存储一个八位字节（8位）
    - Array的初始值是按列输入的明文块。
    - Array的初始值是按列输入的明文块。
    - 加密完成后的State Array会被按列读取，得到密文块。
- 密钥扩展方案
  - 密钥在AES中被组织为一个密钥集序列
  - 初始密钥集由K列，每列包含4个八位字节（32位）组成。密钥扩展过程会生成(r+1)×B个4个八位字节（32位）的列，用于每一轮的轮密钥加操作。
- <img src="./images/image-20230517163505115.png" style="zoom:50%;" />
- S-盒代替（S-box substitution）：S-盒是一个用于进行字节替代的查找表。在S-盒代替操作中，每个八位字节被替换为另一个八位字节，具体的替换规则由S-盒表格决定。S-盒代替操作是AES中的一个重要步骤，用于增加密码算法的非线性性和混淆性。
- 行移位（Row shifting）：行移位操作涉及对State Array中的行进行循环移位。具体来说，每一行向左循环移位的位数取决于行的索引。这个操作通过改变数据在State Array中的位置，增加了算法的扩散性和抗差分攻击的能力。
  - <img src="./images/image-20230517163945854.png" alt="image-20230517163945854" style="zoom:33%;" />
- 列混淆（Mix-Column）：列混淆操作涉及将一个4个八位字节的列替换为另一个4个八位字节的列。这个操作使用了一个特定的查找表，根据列中的每个字节的值来查找对应的替换值。列混淆操作提供了算法的扩散性和抗线性攻击的能力。
  - <img src="./images/image-20230517164028817.png" alt="image-20230517164028817" style="zoom:33%;" />
- 当前Ki的位异或（Bit-wise XOR with current Ki）：这个操作涉及将当前轮密钥（Ki）与State Array中的数据进行位异或运算。位异或操作是一种逐位比较操作，将两个二进制数对应位上的值进行异或运算，结果是一个新的二进制数。这个操作用于将轮密钥与数据进行混合，增加加密算法的安全性。

### &&公私密钥（非对称加密）

- 使用一对两个密钥，发送端和接收端**不共享**关于自己密钥的信息
- 每个端都有私钥和公钥，私钥只有自己知道，公钥大家都知道
- 公钥用于加密，私钥用于解密
  - <img src="./images/image-20230517151626714.png" alt="image-20230517151626714" style="zoom:33%;" />
- Decrypt(Encrypt(M, PUBA), PRVA) = M：将明文M使用A的公钥PUBA加密，然后使用A的私钥PRVA解密，最终得到原始明文M。
  - 用于加密数据传输
- Decrypt(Encrypt(M, PRVA), PUBA) = M：将明文M使用A的私钥PRVA加密，然后使用A的公钥PUBA解密，最终得到原始明文M。
  - 可以用于进行发送者的身份验证
- 即使有公钥和算法，也应该很难得到私钥

#### &&RSA算法

- 数学原理<img src="./images/image-20230517152342157.png" alt="image-20230517152342157" style="zoom:33%;" />
  -  <img src="./images/image-20230517154016065.png" alt="image-20230517154016065" style="zoom:50%;" />
- 思想：把任何信息看作01串进一步看作一个数字
  - m= 10010001=>145.
  - 例如把字母的序号作为值：a=1,b=2...
  - 单词看作二进制拼接后的值
  - dog=>00100 01111 00111=>4583
- 过程
  - 选择两个很大的素数p、q（500-1024bits）
  - 取$ N = p × q$   $Φ = (p–1)×(q–1)$（欧拉函数，计算小于N并与N互素 的整数个数）
    - 选择一个e   $GCD(e, Φ) = 1$
    - 找到e的模反元素（$(d×e) mod Φ = 1$）
  - Public Key: (e, N), and Private Key: (d, N)
  - 发送：
    - 使用e作为指数，N作为模数
    - $C = M^e(mod N)$
    - 发送$C$
  - 接收：
    - $M=C^d(modN)$(由欧拉定理还原出了M！)
- 例
  - <img src="./images/image-20230517154621402.png" alt="image-20230517154621402" style="zoom: 50%;" />
  - <img src="./images/image-20230517154635699.png" alt="image-20230517154635699" style="zoom:50%;" />
- 强度:
  - 素数 p 和 q 应该具有**大致相同**的长度。在RSA算法中，安全性依赖于大素数的难解性。确保 p 和 q 长度相近可以提高算法的安全性。（p 和 q 的长度约为 N 的一半。）
  - 素数 p 和 q 应该是不相关的。这意味着它们之间不应该存在简单的数学关系，以防止攻击者利用这些关系破解加密。
  - 公钥指数 e 可以选择**较小的值**。公钥指数通常是一个较小的常数值，用于加密过程，因为它不会对加密过程增加太大的负担。
  - 私钥指数 d 必须选择一个**较大的值**。私钥指数用于解密过程，需要足够大的值以确保解密的安全性。
  - RSA的强度取决于以下事实：
    - 使用大的 N，其中包含大的素数因子，因子分解是一个困难的问题。
    - N 的长度可以增加以增强加密算法的安全性。
- 反向使用（身份验证）
  - <img src="./images/image-20230517155448128.png" alt="image-20230517155448128" style="zoom: 50%;" />
- 问题：
  - 在RSA加密算法中，指数运算是计算密集型的操作。加密和解密过程中需要进行大数的指数运算，这需要**较长的计算时间和资源**。
  - DES对比RSA在计算效率上至少快100倍。DES是一种对称密钥算法，相对于RSA的指数运算，DES的加密和解密操作更快。
- 应用;
  - 使用公钥加密算法**建立安全连接**，然后建立第二个密钥，即对**称会话密钥**，用于数据加密。
  - Bob和Alice使用RSA加密算法来交换对称密钥KS。这意味着Bob和Alice使用各自的公钥加密KS，并通过互相交换加密后的密文来实现对称密钥的安全传输。
  - 一旦Bob和Alice都获得了KS（对称密钥），他们将使用对称密钥密码算法进行加密和解密操作。对称密钥算法在性能上比公钥加密更高效。

## 身份验证

- 发展
  - ap1.0:
    - <img src="./images/image-20230525203601328.png" alt="image-20230525203601328" style="zoom:25%;" />
  - ap2.0:
    - <img src="./images/image-20230525203624788.png" alt="image-20230525203624788" style="zoom: 25%;" />
  - ap3.0
    - <img src="./images/image-20230525203647606.png" alt="image-20230525203647606" style="zoom: 25%;" />\
  - ap3.1:
    - 仍然不是安全的<img src="./images/image-20230525203801039.png" alt="image-20230525203801039" style="zoom:33%;" />
- ap4.0
  - <img src="./images/image-20230525204338521.png" alt="image-20230525204338521" style="zoom:33%;" />
  - 防止遭受"录制"攻击，每次使用**不一样**的R
  - alice使用密钥**对称**加密R并回复
- ap5.0
  - <img src="./images/image-20230525204540436.png" alt="image-20230525204540436" style="zoom:33%;" />
    - 使用非对称加密
  - 安全漏洞（中间人窃听漏洞）
    - <img src="./images/image-20230525205210332.png" alt="image-20230525205210332" style="zoom:33%;" />
    - 图片左右没对上，大致意思是攻击者伪装alice与bob通信，并让bob误以为自己与alice通信（记录的公钥为攻击者的）
    - 同时与Alice通信建立了连接
    - 在之后的通讯中，攻击者可以解码bob发送给alice的信息进行查看，再转交给alice，而**不会被发现**
      - 使用自己的公私钥与bob进行通信，使用alice的公私钥与alice进行通讯
    - 这种情况下的中间人攻击具有危险性，因为攻击者可以**窃取**敏感信息、篡改通信内容或执行其他恶意操作，而受害者完全**不知情**。为了防止中间人攻击，通信双方应该采取额外的安全措施，例如使用加密技术、数字证书和身份验证来确保通信的安全性和真实性。

## 信息完整及认证

- 确认信息的来源正确，并且没有被篡改

### 消息认证码

- 发送者计算并发送认证信息作为常规信息的一部分，接收者将收到的认证信息与预期的信息比较

- <img src="./images/image-20230525210441006.png" alt="image-20230525210441006" style="zoom: 33%;" />

#### 基本概念

- MAC（Message Authentication Code）一个附加在消息**末尾**的**固定长度代码**：消息认证码（MAC）是一个固定长度的代码，它会附加在要传输的消息末尾。它用于验证消息的完整性和真实性。
  - 典型的MAC大小范围从64到256位
- 可以在不加密的情况下发送明文消息：由于**MAC用于验证消息的完整性**和来源，可以在**没有加密**的情况下发送明文消息。通过验证MAC，接收方可以确保消息**未被篡改**，并且来自所声称的发送者。
- MAC是消息和密钥的函数：MAC是**根据消息和一个密钥生成**的。通过使用特定的哈希函数或加密算法，将消息和密钥作为输入，生成MAC作为输出。只有**知道密钥**的合法方能够验证和生成正确的MAC。
  - 把密钥添加进来是为了防止攻击者将信息内容与MAC全部修改

- MAC不应该可逆，**不需要解密**
- MAC的强度取决于**函数和密钥**的保密性：MAC的安全强度取决于所使用的函数（例如哈希函数）的安全性和密钥的保密性。使用强大的哈希函数和足够长的密钥可以增强MAC的安全性，使其难以被破解或伪造。

#### 性质

- 可以处理**任何长度**的消息而自身的长度固定
- 可以被快速计算出来 
- 具有单项性
  - 已知MAC为X的情况下，很难找到一个数据Y满足MAC(Y)=X。这个属性确保了认证码的不可逆性，防止未授权的人通过认证码推导出原始消息内容。
- 弱碰撞抗性
  - 给定一个消息X1，很难找到另一个消息X2，使得MAC(X1) = MAC(X2)。这意味着很难找到两个不同的消息产生相同的认证码。这个属性确保了在给定一个消息的情况下，很难找到另一个与之碰撞（具有相同认证码）的消息。
- 强碰撞抗性
  - 很难找到任意两个不同的消息X1和X2，使得MAC(X1) = MAC(X2)。这意味着在整个消息空间中，很难找到任意两个不同的消息具有相同的认证码。这个属性确保了在整个消息空间中，很难找到任意两个碰撞（具有相同认证码）的消息。

#### 通过加密进行身份验证

##### CBC-MAC

- 计算过程
  - 将待认证的消息M分割成长度为n位的L个块（$M=M_1,...,M_L$）
  - 选择一个秘密密钥K，用于加密算法E。
  - 选择一个随机的初始向量（IV），作为初始的前一个密文块$C_0$
  - $C_i = E_K(M_i+C_{i–1})i = 1, 2, . . ., L$
    - 对于每个消息块Mi，使用加密算法E和密钥K对其与前一个密文块Ci-1进行加密运算，得到当前密文块Ci。
  - $CBC-MAC=C_L$
    - 将最后一个计算得到的密文块CL作为CBC-MAC的输出，作为消息M的认证码。
  - $MAC_K(M) = (C_0, C_L) = (IV, CBC-MACK(M))$
    - 将初始向量$C_0$和最后一个密文块$C_L$组合在一起，形成完整的CBC-MAC认证码$MAC_K(M)$

#### 通过哈希进行身份验证

- <img src="./images/image-20230530190638053.png" alt="image-20230530190638053" style="zoom:50%;" />
  - 输·	入要小于$2^{64}$bits，划分为512bits的块
  - 对数据进行进行扩展，使得长度满足448(mod 512)
    - 填充一个1和多个0
  - 最后64位为原始数据的长度
  - 由初始向量与块中的每个单元进行计算处理得到最终的校验数

##### &&MD5

- 长度：128bit
- 使用一个四个字的缓冲区（一个分组）（16字节，128bits），初始值为` 01234567, 89abcdef, fedcba98, 76543210`(16进制)作为计算的起点
  - 此后均使用上一次计算的结果作为初始值
  - 处理一个块（512bits）需要拆分为16个字（32bits)

- 将消息分成长度为16个字的块进行处理，每个块由 M0, M1, … M15 组成，$M_i$表示块中的每个字
- 处理消息块的过程分为4个阶段（即主循环有四轮,内层循环有16轮），每个阶段Using F, modular +, and left rotation进行处理
- MD5对一个block数据要进行**16次**（512/32）完全相同的一套完整操作，一套完整的操作包括**4轮**向量运算。也就是说，**每32bits明文数据为一个单位，要进行4轮的向量运算；而每一个block要对16个（32bits）单位明文数据进行运算，共计64次。**
- 每个阶段包括16个相似的操作，用于处理块中的**每个字**。
- <img src="./images/image-20230525214552094.png" alt="image-20230525214552094" style="zoom:33%;" />
  - M是要进行处理的数据的一个**16个字**的块


##### SHA-1

- 160bit
- 使用5个字，初始值`67452301, efcdab89, 98badcfe, 10325476,  c3d2e1f0`
- 将消息分成长度为16个字的块进行处理，每个块由 M0, M1, … M15 组成，$M_i$表示块中的每个字
- 有四个阶段，每个阶段使用不同的F进行处理，并且包含20个操作
- <img src="./images/image-20230525215122785.png" style="zoom:33%;" />
- <img src="./images/image-20230525215158027.png" alt="image-20230525215158027" style="zoom:33%;" />

### 数字签名

- <img src="./images/image-20230525215403289.png" alt="image-20230525215403289" style="zoom:33%;" />
- 一种不依赖对称密钥的使用公私钥的认证过程
- Bob使用私钥对生成的校验码进行加密
- Alice使用公钥对加密的校验码进行解码，并与重新计算的到的校验码进行比较

## 密钥分发

- 问题
  - 在安全通信中，Alice和Bob需要共享一个秘密密钥，但问题是如何**安全地**将密钥传输给对方
  - 在公钥加密中，Alice需要确定接收到的公钥**确实属于**Bob，而不是被篡改或伪造。
- 解决方法
  - Diffie-Hellman密钥交换协议
    - 通过公开的通信渠道协商出一个共享的秘密密钥，而不需要在传输过程中直接共享密钥。该协议基于数学问题的难解性，确保第三方无法推断出实际的密钥值。
  - 可信任的认证机构（CA）
    - 使用机构颁发的数字证书，包含了相关信息，并由CA签名以证明其真实性。Alice可以通过CA验证身份。
  - 公钥证书
    - 是由CA签发的包含公钥及其相关信息的文档。证书中的公钥可以被Alice使用，而CA的签名则提供了对公钥真实性的保证。通过获取Bob的公钥证书并验证其合法性，Alice可以确保她拥有正确的Bob公钥。

### Diffie-Hellman

- 过程
  - 选择一个知名的大质数P，以及P的一个原根g（增加破解的复杂度）
    -  <img src="./images/image-20230525221737525.png" alt="image-20230525221737525" style="zoom: 50%;" />
  - A从$Z_P^*$选择一个数$x$，把$X=g^x(modP)$发送给B
  - B从$Z_P^*$选择一个数$y$，把$Y = g^y(modP)$发送给A
  - A得到密钥$Y^xmodP$ 即($g^{xy}modP$)
  - B得到密钥$X^ymodP$
- <img src="./images/image-20230525222247652.png" alt="image-20230525222247652" style="zoom:33%;" />
  - <img src="./images/image-20230530172628139.png" alt="image-20230530172628139" style="zoom: 50%;" />

- <img src="./images/image-20230525220530991.png" alt="image-20230525220530991" style="zoom: 50%;" />

- 会受到中间人**攻击**，但无法直接通过窃听获得密钥
  - ​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            


### 可信任的认证机构

- <img src="./images/image-20230525222422154.png" alt="image-20230525222422154" style="zoom: 50%;" />
- **会话密钥**是一种在逻辑连接期间使用的密钥。它会在会话结束时销毁，并且不是永久性的密钥。
- Permanent key主要作用是用于**密钥分发**。
- CA负责确定发送方和接收方的身份有效性，并为该连接提供一个会话密钥。会话密钥用于在通信过程中的加密和解密操作。

#### The Needham-Schroder Protoco

- 由于公钥加密算法通常不适合对大块消息进行加密，因此在通信中，使用一次性会话密钥来实现加密。

- 安全服务模块（Security Service Module，SSM）在整个通信链路中扮演重要角色。SSM负责执行**端到端**的加密操作，并获取用于主机的密钥。
- <img src="./images/image-20230525223110925.png" alt="image-20230525223110925" style="zoom:33%;" />
  - 初始状态下AS、C、S都有各自的长期公私密钥
  - C向AS发送请求，希望与S进行对话
  - AS为CS的会话生成密钥$K_{cs}$并用AS和S之间共享的公钥进行加密，外面再用C和AS之间共享的公钥进行加密
  - C收到信息后用私钥进行解码得到K，然后把内层加密的K发送给S，S使用私钥进行解码
  - S使用AS提供的CS之间的会话密钥加密随机数发送给C，C解码后得到N，计算出N-1再加密后返还给S，确认通讯建立（建立对称加密）

### 公钥证书

- 另一种密钥传输方式
  - Bob准备一条消息，将要发送给Alice。
  - Bob使用对称加密算法，使用一个一次性会话密钥对消息进行加密。
  - Bob使用Alice的公钥对一次性会话密钥进行加密。
  - Bob将加密后的一次性会话密钥附加到消息上，并将消息发送给Alice。
  - Alice收到消息后，使用自己的私钥解密获取一次性会话密钥。
  - Alice使用一次性会话密钥对消息进行解密，以获取原始的明文消息。
- 问题：公钥可能并不是A的，B可能被欺骗
  - 因此引入公钥证书
- 公钥证书包含：
  - 公钥
  - 用户ID
  - CA颁发的带有时间戳的证书
- 由此其他人无法用自己的公钥来替代A的公钥，因为CA的签名是无法伪造的（使用私钥加密，公钥解密-身份认证）
- <img src="./images/image-20230525225404965.png" alt="image-20230525225404965" style="zoom:33%;" />
  - 首先申请者准备好信息内容，使用hash生成校验码，发送给AC，AC使用公钥进行认证
- <img src="./images/image-20230525225628883.png" alt="image-20230525225628883" style="zoom:33%;" />
  - 序列号：每个证书都有一个唯一的序列号，用于标识该证书的**唯一性**。
  - 证书所有者信息：包括**证书所有者**的相关信息，如姓名、电子邮件地址等。还包括算法和密钥值相关的信息，用于指定证书的加密和签名算法。
  - 证书颁发者信息：包括**证书颁发者**（CA）的相关信息，如名称、电子邮件地址等。还包括证书的有效日期范围，即证书的生效日期和过期日期。
  - 数字签名：证书颁发者会对证书的内容进行**数字签名**，以确保证书的完整性和真实性。签名结果也称为指纹（thumbprint）或摘要（fingerprint），它是对**证书内容进行哈希计算得到的固定长度的值**。

### 邮件PGP

- <img src="./images/image-20230525225744882.png" alt="image-20230525225744882" style="zoom:33%;" />

  - Alice生成一个随机的对称密钥$K_s$
  - 同时发送使用对称密钥加密的信息$K_s(m)$和使用Bob的公钥加密的$K_B(K_s)$
  - Bob使用私钥解码得到对称密钥再得到信息m

- Alice希望提供发送者身份验证和消息完整性<img src="./images/image-20230525230334028.png" alt="image-20230525230334028" style="zoom:33%;" />

  - Alice发送m和m的校验码$H(m)$（使用私钥进行加密，防止被篡改）方便Bob与m进行比对

  - 若Alice希望提供保密性、发送者身份验证和消息完整性<img src="./images/image-20230525230351339.png" alt="image-20230525230351339" style="zoom:33%;" />
    - 对上面的m和$H(m)$再使用对称密钥进行加密，同时传输使用Bob的公钥加密的对称密钥

## 传输层网络安全

- 端到端加密
- 传输层加密可以确保**数据**在传输过程中的**保密性**，但在网络中的其他节点上可能仍然可以观察到传输的**元数据**（如源IP地址、目标IP地址、端口号等）。

### SSL标准

- 保护应用数据安全传输，保护一个**互动数据流**（连接）
- 需要验证**服务端**的身份
- <img src="./images/image-20230526101422642.png" alt="image-20230526101422642" style="zoom: 33%;" />

- <img src="./images/image-20230526101504812.png" alt="image-20230526101504812" style="zoom:33%;" />
  - 加一层SSL，使用SSL的api发送数据，而不是tcp
- 理念
  - 握手认证，双方通过公私密钥互相认证，得到一个统一的**对称密钥**MS（主密钥）
  - 使用共享密钥传输一系列密钥（共享密钥作为生成种子）
  - 使用生成的**不同密钥**数据**分块**传输
    - 不同密钥
      - Kc：用于从客户端发送到服务器的数据的加密密钥。
      - Mc：用于从客户端发送到服务器的数据的MAC密钥。
      - Ks：用于从服务器发送到客户端的数据的加密密钥。
      - Ms：用于从服务器发送到客户端的数据的MAC密钥。
      - 这些密钥是通过密钥派生函数（KDF）**生成**的。KDF接受主密钥和（可能还有）一些附加的随机数据，并创建这些密钥。
    - 分块（最小单位，成为**记录**）
      - 一个分组（数据包）会包含多条记录
      - <img src="./images/image-20230526102417992.png" alt="image-20230526102417992" style="zoom:33%;" />
      - 将数据流分解为一系列块。**每个块都携带自己的MAC**，使得接收方可以在每个记录到达时立即进行处理。这样可以更快地在每个记录上检测篡改或损坏，而**不需要**等待整个数据流的接收完成。
      - 问题：攻击者可以捕获并重放记录，或者重新排序记录。
        - 在MAC中**加入序列号**：
        - MAC = MAC(Mx, sequence || data)
      - 问题：攻击者可以重放所有记录。 
        - 解决方案：使用一次性数字（nonce）标记数据。
  - 安全关闭连接
    - 问题：截断攻击。
      - 攻击者可以伪造TCP连接关闭段。
      - 解决方案：
        - 使用记录类型，并为连接关闭操作定义一个特殊的记录类型。即使用**加密和MAC**保护信息
        - 类型0表示数据记录。
        - 类型1表示连接关闭记录。
        - <img src="./images/image-20230526103554883.png" alt="image-20230526103554883" style="zoom:33%;" />
- <img src="./images/image-20230526102851211.png" alt="image-20230526102851211" style="zoom:33%;" />

### 真实SSL

- SSL是一个基于TCP的安全协议，旨在为通信提供保密性、完整性和身份验证。它通过在TCP协议之上添加两层协议实现安全性。
- 服务组成<img src="./images/image-20230526103752600.png" alt="image-20230526103752600" style="zoom: 50%;" />
  - 记录（块）协议（Record Protocol）：提供基本的安全服务给各种高层协议使用。它负责将数据**分割**成记录，并对每个记录进行**加密、完整性校验和解密**等操作。
  - 在SSL中，还有三种管理SSL交换的高层协议，这些协议嵌入在特定的软件包中，如IE（Internet Explorer）或Netscape中。这些高层协议用于管理SSL**握手过程、证书交换、密钥协商和身份验证**等操作。
- 首先服务器和客户端之间需要通过握手协议建立**会话**session
  - 在这个关联中，每个实体（客户端和服务器）都具有一组密码安全参数
    - 对等方（服务器）的证书：用于公钥的验证和身份认证。
    - 48字节的主密钥：用于**共享密钥**的生成。
    - 压缩算法、加密算法或MAC（哈希）算法的选择：用于通信数据的压缩、加密和完整性保护。
  - 这种关联可以在一个应用程序的客户端和服务器之间建立**多个**（TCP）连接。这样做的目的是避免为每个连接都重新协商新的安全参数。通过共享已建立的关联，可以节省计算资源和时间。
- 数据结构
  - <img src="./images/image-20230526104324944.png" alt="image-20230526104324944" style="zoom:33%;" />

#### 应用层协议功能

- 更改密码规范协议
  - 一个单个字节的消息，其值设置为1
  - 服务器和客户端进行沟通，决定要选择的加密策略与算法（双方都支持的交集）
- 警报协议
  - 警报消息会被压缩和加密以保证安全性。
  - 警报级别：可以是1（警告）或2（严重）。
    - 如果级别为严重（2），SSL会立即终止连接。（但是一个session会有多个连接，其他连接不会被立即关闭，但是会话不再接受新的连接的建立）
    - 如果级别为警告（1），SSL会继续进行，但会向对等实体发出警告。
  - 警报描述：根据情况不同，可能有不同的描述。
    - 严重警报描述（Fatal）包括：UnexpectedMessage（意外的消息）、BadRecordMAC（错误的记录MAC）、HandshakeFailure（握手失败）等。
    - 警告警报描述（Warning）包括：CloseNotify（关闭通知）、Certificate Unsupported/Revoked（证书不支持/已废止）、Illegal Parameter（非法参数）等。
  - <img src="./images/image-20230526105116964.png" alt="image-20230526105116964" style="zoom: 50%;" />
- 握手协议
  - **身份验证**发送方/接收方：握手协议用于验证通信的发送方和接收方的身份。这确保了通信双方的身份是可信的，并防止中间人攻击。
  - **协商**加密算法、MAC算法和密钥：握手协议用于协商通信双方所使用的加密算法、消息认证码（MAC）算法和密钥。通过协商这些参数，握手协议确保了通信的保密性和完整性。
  - 握手协议通常包括四个回合
    - 建立安全能力：通过握手协议，客户端和服务器之间建立了SSL连接，**并确定了双方的安全能力**。这包括使用的加密算法、MAC算法和密钥长度等参数。
    - 服务器鉴别与密钥交换：服务器在握手过程中对自身进行身份验证。它向客户端提供适用于共享密钥分发的公钥，以确保通信的安全性。
    - 客户端验证服务器并开始密钥交换：客户端对服务器进行验证，并开始进行**密钥交换**。这确保了客户端与合法的服务器进行通信，并建立了共享密钥。
    - 交换确认：在握手过程中，各个阶段都会进行确认，确保握手的每个步骤都得到了正确执行。
    - 根据协商更改密码规范：一旦握手协议的各个阶段完成，通信双方根据协商的结果改变密码规范。这意味着双方根据握手协议中达成的协议更改加密算法、MAC算法和密钥等参数。
- *握手协议的具体过程<img src="./images/image-20230526105713527.png" alt="image-20230526105713527" style="zoom:50%;" />
  - 握手报文也要MAC，防止被篡改（如删除更安全的方法）
  - phase1
    - 主要用于双方的初步沟通，确定协议方案、算法等选择
    - <img src="./images/image-20230526143712494.png" alt="image-20230526143712494" style="zoom: 50%;" />
    - **ClientHello**消息由客户端发送给服务器，其中包含以下字段：
      - vC：客户端支持的SSL/TLS版本。
      - r1：随机数（nonce），用于加密密钥生成。
      - sid：当前会话ID（如果是新会话，则为0）。
      - Ciphers：客户端支持的加密算法列表。
      - Comps：客户端支持的压缩算法列表。
    - **ServerHello**消息由服务器发送给客户端，其中包含以下字段：
      - V：客户端和服务器都支持的最高SSL/TLS版本。
      - r2：随机数（nonce），用于加密密钥生成。
      - sid：当前会话ID（如果是新会话，则为0）。
      - Cipher：要使用的加密算法。
      - Comp：要使用的压缩算法。
    - 在第一轮握手之后，，服务器进行选择，客户端得知以下信息：
      - SSL版本。
      - 密钥交换、消息认证和加密算法的加密算法。
      - 压缩算法。
      - 用于密钥生成的两个随机数。
    - 客户端和服务端使用相同的导出函数以及随机数导出相同的主密钥MS
      - 使用共享主密钥MS切片得到用于加密不同部分的密钥以及随机向量等信息，用于之后的加密传输
    - 需要两个随机数，假设Trudy窃听了Alice和Bob之间的所有消息。第二天，Trudy与Bob建立了一个TCP连接，并发送了完全相同的记录序列。Bob（Amazon）会认为Alice对同一件事进行了两次不同的订单。为了解决这个问题，Bob在每个连接中发送不同的随机数（nonce）。这样会导致两天的加密密钥**不同**，确保了安全性。
  - phase2
    - <img src="./images/image-20230526144038159.png" alt="image-20230526144038159" style="zoom:50%;" />
    - certificate**服务器证书**：在建立新会话时，服务器需要提供其证书给客户端。
    - server_key_exchange**密钥交换**：
    - certificate request 客户端证书（可选）：服务器**可能**要求客户端提供其证书
    - Server_hello done：一旦服务器完成必要的握手步骤，包括证书交换和密钥协商，它会发送Server_hello done消息，表示**服务器握手阶段已完成**。
  - phase3(可选，客户端证明自己的身份)
    - <img src="./images/image-20230526144048188.png" alt="image-20230526144048188" style="zoom:50%;" />
    - certificate证书验证（如果需要）：**客户端**可能需要验证服务器提供的**证书**的有效性。
    - client_key_exchage：客户端将生成的密钥用**服务器公钥加密**并返回
    - 检查Server_hello参数
    - 发送密钥信息
  - phase4（进行最终的验证和确认）
    - <img src="./images/image-20230526144059686.png" alt="image-20230526144059686" style="zoom:50%;" />
    - 客户端发送change_cipher_spec消息：客户端将等待中的CipherSpec复制到当前的CipherSpec中，表示要使用**新**的加密和认证算法。这个消息使用Change Cipher Spec协议发送。
    - 客户端发送finished消息：在新的算法、密钥和密钥信息下，客户端发送finished消息。该消息用于验证密钥**交换和认证是否成功**。它包含对之前握手阶段的摘要，以确保握手过程的完整性和正确性。
      - 客户端和服务器会**分别**生成一个"Finished"消息，用于验证握手过程的完整性。"Finished"消息中包含一个**散列值**（Hash），该散列值是使用握手过程中协商的**密钥和参数对握手消息进行摘要计算得到的**。客户端和服务器会根据各自的计算结果生成并发送"Finished"消息。
      - 接收到对方发送的"Finished"消息后，接收方会进行验证。它会使用相同的密钥和参数对收到的握手消息进行摘要计算，然后将计算结果与对方发送的"Finished"消息中的散列值进行比较。如果计算结果匹配，说明握手过程的完整性得到了确认，连接建立成功。
      - 即确认之前握手过程中的报文没有被篡改
      - 这两次发送MAC都包含了发送之前**所有的握手报文**
    - 服务器发送change_cipher_spec消息：服务器**响应**客户端的change_cipher_spec消息。它将等待中的CipherSpec转移到当前的CipherSpec中，表示服务器也要使用新的加密和认证算法。然后，服务器发送自己的finished消息。
    - 服务器发送finished消息：服务器在新的算法、密钥和密钥信息下发送自己的finished消息。这个消息用于验证密钥交换和认证是否成功，**并确认握手过程的完整性和正确性。**（比上面第一次发**多了两条**新记录）
- <img src="./images/image-20230526144955405.png" alt="image-20230526144955405" style="zoom:33%;" />
  - 每个上层消息在传输之前被分割成较小的片段。如果启用了压缩，压缩后的消息加上消息认证码（MAC）会使用对称加密进行加密。
- PDU
  - 会在协议数据单元（PDU）前添加SSL记录头部，并将整个PDU通过TCP段进行传输。
  - <img src="./images/image-20230526145119058.png" alt="image-20230526145119058" style="zoom:33%;" />
    - 协议类型（1个字节）：指示记录类型。其中20表示change_cipher_spec（变更密码规范）、21表示警报、22表示握手、23表示应用层数据。
    - 主要版本号（1个字节）：指示SSL的主要版本。SSL v3的主要版本号是3。
    - 次要版本号（1个字节）：指示SSL的次要版本。SSL v3的次要版本号是0。
    - 压缩长度（2个字节）：指示压缩后的消息长度。每个字节可以达到最大值214+2048。
    - MAC（0、16或20个字节）：用于消息完整性检查的消息认证码。其长度根据使用的MAC算法而变化。

## 网络层网络安全

- ip加密，站到站
- 网络层加密提供了更高级别的安全性，保护整个通信链路中的**数据和通信元数据**。

### IPSec

- 服务：
  - 数据**完整性**
  - 发起者**认证**
  - **防止重放**攻击（Replay Attack Prevention）这确保了接收方不会接收到重复的或过期的数据包。
  - **保密性**（Confidentiality）
- 应用示例：
  - 分支机构通过互联网连接：IPsec可以用于建立安全的分支机构与总部之间的通信连接，以保护数据的机密性和完整性。
  - 安全的远程访问（用户到站点）
  - 服务器之间的流量加密
  - 增强的电子商务安全性

#### VPNs（虚拟私有网络）

- 动机：

  - 机构通常希望建立私人网络以增强安全性。

  - 传统的私人网络建设成本较高，需要使用独立的路由器、链路和DNS基础设施。

  - VPN可以通过在公共互联网上发送机构的办公室间流量，从而降低成本。
    - VPN会在数据进入公共互联网**之前进行加密**，确保数据的安全性。
    - VPN在**逻辑上与其他流量隔离**，实现了逻辑上的分离。

- 目的：

  - VPN的主要目的是在公共互联网上建立**安全的通信通道**，用于机构**内部**的数据传输。

  - 通过对数据进行加密，VPN确保数据在通过公共互联网传输时的保密性。

  - VPN使机构的办公室间流量在逻辑上与其他公共互联网流量隔离，提供了一定程度的隐私和安全保护。

- <img src="./images/image-20230526111953783.png" alt="image-20230526111953783" style="zoom:33%;" />

#### 传输模式和隧道模式

- <img src="./images/image-20230526112118194.png" alt="image-20230526112118194" style="zoom: 50%;" />
  - 传输模式
    - <img src="./images/image-20230526112432256.png" alt="image-20230526112432256" style="zoom: 50%;" />
    - 传输模式提供端到端的加密，主要用于远程访问场景。
    - 使用传输模式，终端设备必须实现IPsec协议。
    - 在传输模式下，IPsec仅对IP数据包的**有效负载**进行加密，而**IP头部保持原样**。
    - 传输模式通常用于直接连接的通信，例如远程用户与企业内部网络之间的通信
  - 隧道模式
    - <img src="./images/image-20230526112448636.png" alt="image-20230526112448636" style="zoom: 50%;" />
    - 隧道模式通常用于防火墙之间的通信，并用于构建虚拟私人网络（VPN）。
    - 使用隧道模式，IPsec会加密**整个IP数据包**，**包括IP头部和有效负载**。IP数据包的头部中的IP地址是**IPSec网关**的地址，而**不是**实际的源和目的地址。
    - 隧道模式用于在**不安全的网络**上加密所有流量，确保通信的机密性和安全性。
    - 在隧道模式下，通信的两端需要配置**IPsec隧道**，以便在两个隧道终点之间进行加密和解密。

#### IPsec协议策略

- 认证协议AH
  - 认证协议用于提供数据包的认证，但**不**对消息进行加密。
  - AH协议通过在IP数据包中添加**认证头部**来实现数据的**完整性验证**和源身份验证。
  - AH协议负责在**整个IP数据包**上进行额外的数据完整性校验，并验证数据的源身份。
- 封装安全载荷协议ESP
  - 封装安全载荷协议提供了消息的**加密和认证。**
  - ESP协议通过将IP数据包的有效载荷进行加密和认证来保护数据的机密性和完整性。
  - 分为头部和尾部，夹住数据
    - 头部提供了**协议参数和选项**的定义和传递，尾部则提供了**完整性保护和数据验证的能力**。
  - ESP协议负责对**有效载荷**进行加密，并添加校验码以验证数据的完整性。
- Internet密钥交换协议AKE
  - IKE协议用于在两个对等体之间协商安全功能和密钥。
  - 用于**建立**和管理IPsec安全**关联**                                                                                                                                                                                                                                                   
- <img src="./images/image-20230526113232034.png" alt="image-20230526113232034" style="zoom:33%;" />

#### SA安全关联

- 在发送数据之前，发送方和接收方之间会建立一个称为"安全关联"的SA，用于定义双方之间的**单向关系**。用于**描述安全通信的参数和策略**。
- 为了进行全双工通信，通常需要建立**两个SA**。
- 发送方和接收方**维护关于SA的状态信息**，类似于TCP端点维护的状态信息。

  - IP是无连接的，而IPsec是**面向连接**的，因此需要建立和维护SA来确保安全通信。
- 安全参数索引（Security Parameters Index，SPI）用于确定接收到的数据包应该使用**哪个SA**进行处理。

  - 每个主机都有一个**包含SA的表**，SPI是用于查找特定SA的**索引**(用于**标识和区分**不同安全关联SA)。
  - SPI在两个对等体之间具有**本地意义**，没有全局意义。
- 配置内容<img src="./images/image-20230526113922386.png" alt="image-20230526113922386" style="zoom: 50%;" />

  - SA标识符：（SPI）
  - 源SA接口
  - 目的SA接口
  - 安全协议（AH&ESP）
  - 使用的加密类型（DES、AES）
  - 加密密钥
  - 认证密钥

##### 帧结构

- <img src="./images/image-20230526114637246.png" alt="image-20230526114637246" style="zoom: 50%;" />
  - ESP Header：用于封装加密和认证的数据。它包含ESP的各种**参数和选项**，如加密算法、认证算法、SPI等。
    - SPI：SPI是一个32位的标识符，用于唯一标识与IPsec相关的安全关联。
    - Seq#（Sequence Number）：Seq#是一个用于**序列化**IPsec数据报的字段，用于确保IPsec数据报的顺序性和完整性。
      - ESP通过使用序列号字段在ESP头部中**防止重放攻击**。
      - 每当在SA上发送数据报时，发送方会递增序列号计数器，并将其放置在序列号字段中。
  - ESP Trailer：ESP尾部，包含填充字段和填充长度等。
    - Authenticated Padding：填充字段，用于填充ESP尾部的长度，以满足加密算法的要求。
    - Pad Length：填充长度字段，指示填充字段的长度。
    - Next Header：下一个头部字段，指示在ESP封装后的数据中紧随ESP头部之后的下一个头部类型。
  - ESP auth校验码
    - 使用共享的**密钥**创建的消息认证码（MAC），用于验证数据的完整性和防止数据被篡改。
- 生成过程
  - R1将**原始数据报**追加到IPsec数据报的末尾
  - R1使用SA指定的算法和密钥对数据进行**加密**
  - R1在加密数据前附加**ESP头部**
  - R1使用SA指定的算法和密钥创建认证**MAC**
  - R1将认证MAC附加到"enchilada"的**末尾**。
  - R1创建全新的IP头部：R1创建一个**全新的IP头**部，其中包括经典的IPv4头部字段。这个新的IP头部位于有效载荷的前面，形成了最终的IPsec数据报。

##### IKE

- 互联网key交换协议，帮助**建立**ipsec连接
- 内容
  - 协商安全算法
  - 身份验证
  - 交换对称会话加密密钥
- 功能
  - 密钥交换：IKE协议提供一种安全的方式来交换对称密钥或非对称密钥，以便在通信节点之间建立安全通信。它使用Diffie-Hellman密钥交换算法，允许节点在不直接交换密钥的情况下生成共享密钥。
- 身份认证方式
  - PSK预共享密钥
    - 通信双方事先共享一个秘密密钥（如使用Diffie-Hellman生成）。它们使用IKE协议来相互验证身份并生成IPsec安全关联，不会暴露自己的公私钥造成信息的泄露。
  - PKI公钥基础设施
    - 通信双方分别拥有公钥和私钥，并持有相应的证书。它们使用IKE协议来相互验证身份，并获取IPsec安全关联（协商算法与加密方式等信息）。

## 补充

### 无线网络安全

#### 802.11标准

- 使用身份认证+加密
- 采用"有线等效隐私"（Wired Equivalent Privacy，WEP）但这一方法被证明存在漏洞，安全性不足。（现在实际使用的是802.11i）
  - 它使用共享密钥，由一个**40位的主密钥**（WEP密钥，加密和解密数据的**共享密钥**）和一个24位的初始化向量（IV）组成（每个帧内使用一个）。（IV用于增添一些随机性，生成密钥流）
  - WEP没有密钥分发机制，密钥需要**手动设置**。（wifi密码）
  - 入点（Access Point）假设只有移动设备具有密钥。
- 802.11i
  - 身份验证服务器与接入点分离(类似需要登录的wifi网络)
  - 通过使用独立的身份验证服务器，可以实现更**强大**的加密方式，并且提供更安全的密钥管理。**身份验证服务器**可以负责生成和分发密钥，确保只有授权的设备能够访问网络。
  - 通过将身份验证和密钥管理功能与接入点分离，可以提供更灵活、可扩展和安全的无线局域网解决方案，使得不同的加密算法和安全机制可以根据需要进行配置和使用。
  - <img src="./images/image-20230526134433711.png" alt="image-20230526134433711" style="zoom: 50%;" />
    - 移动主机和身份验证服务器进行相互认证，确保彼此的身份合法性和信任关系。
    - 在认证成功后，**移动主机和身份验证服务器**共同生成主密钥（KS）。这个主密钥将用于后续的密钥派生和加密过程。
    - 身份验证服务器将生成的主密钥（KS）发送给**接入点**（AP）。接入点在后续的通信中将使用这个主密钥进行密钥派生和临时密钥（TK）的生成。
    - **移动主机和接入点**使用主密钥（KS）派生出临时密钥（TK），这个临时密钥用于消息的加密和完整性保护。这个临时密钥在通信过程中动态生成，提供了更高的安全性。

##### WEP

- 认证
  - 移动设备向接入点发送认证请求。
  - 接入点回复一个128位的随机数（用于防止重播攻击（录制））。
  - 移动设备使用共享的主密钥（KS）对随机数进行加密。
  - 接入点解密随机数并对移动设备进行认证。
- 加密
  - 使用主密钥和初始化向量，生成一串密钥流。（种子）
  - 加密器确保相同的64位密钥生成相同的密钥流。
  - 密钥流与明文和校验和进行**异或操作**，生成密文。
  - <img src="./images/image-20230526134250822.png" alt="image-20230526134250822" style="zoom: 50%;" />
- 安全漏洞
  - 如果IV是随机分配的，预期在5000个数据帧中会出现一次**重复**使用的情况。如果IV是顺序分配的，那么在每次启动时都会重新使用IV。
  - 并且IV明文传输，因此IV的重复是会被察觉的
  - 如果攻击者（Trudy）引导Alice加密一个**已知的明文**P1，一旦IV重新出现，攻击者就能够**知道**对应的加密后的密文P2。
    - 对相同的密钥C进行两次加密会使得加密失效
    - <img src="./images/image-20230531112207228.png" alt="image-20230531112207228" style="zoom:33%;" />
    - 或者如果等待两个回合*（相同随机IV输入相同的数字）这杨就能完全解出公钥的序列

### 防火墙

- 理念
  - <img src="./images/image-20230526141656104.png" alt="image-20230526141656104" style="zoom:33%;" />
  - 将组织的内部网络与更大的互联网隔离开来。
  - 允许某些数据包通过，阻止其他数据包。
  - 确保内部网络和系统免受外部的黑客和恶意软件的攻击。
- 功能
  - 防止**拒绝服务**攻击：通过阻止攻击者建立伪造的TCP连接或尝试ping攻击来防止SYN洪泛等类型的拒绝服务攻击。（占用服务器资源，使得服务器无法正常服务用户）
  - 仅允许**授权的访问**进入内部网络：通过设置经过身份验证的用户/主机集合，只允许授权用户/主机访问内部网络。
  - 防止对内部数据的**非法访问/修改**：防止未经授权的用户访问或修改内部数据。
- 分类
  - **无状态数据包**过滤器：基于数据包的**源地址、目标地址、端口**等信息进行过滤，没有**记忆或状态跟踪**能力。
  - **有状态数据包**过滤器：除了基于数据包的信息进行过滤外，还具有**状态跟踪**功能，可以检测和控制数据包的状**态和连接**。
  - 应用程序**网关**：也称为代理服务器，它在**应用层**对网络流量进行过滤和代理，提供更高级的安全性和控制。

#### 无状态数据包过滤

- 防火墙通过检查到达的数据包来确定是否允许进入，同时也检查出去的数据包
- 依据
  - 源IP地址和目标IP地址
  - TCP/UDP源端口和目标端口号
  - ICMP消息类型
  - TCP的SYN和ACK位
- 例子
  - 阻止传输层协议字段为17的入站/出站数据报
    - 所有的入站和出站UDP流量都被阻止
  - 阻止源端口或目标端口为23的入站/出站数据报
    - 所有telnet连接（bbs）都被阻止
  - 阻止ACK位为0的入站TCP段
    - 防止外部客户端向内部主机建立TCP连接（即DOS攻击）
  - <img src="./images/image-20230526142539402.png" alt="image-20230526142539402" style="zoom:50%;" />
- ACL表：控制通过策略
  - <img src="./images/image-20230526142628243.png" alt="image-20230526142628243" style="zoom:50%;" />

##### 有状态数据包过滤

- 有状态的数据包过滤器：**跟踪**每个TCP连接的状态
  - 跟踪连接的建立（SYN）和关闭（FIN）：确定入站和出站数据包是否“合理”
  - 在防火墙上超时处理不活跃的连接：不再允许该连接的数据包通过
- 在访问控制列表（ACL）中增加了一个指示，在允许数据包通过之前需要**检查连接状态表**。

#### 应用程序网关

- 更高级的应用网关可以在应用数据以及IP/TCP/UDP字段上过滤数据包。例如，允许选择的内部用户进行telnet外部访问，但用户认证应该在应用**程序级别**进行。

- 应用网关要求TCP连接必须通过网关进行中继。路由器过滤器会阻止所有不是源自网关的TCP连接。这种方式可以提供更精**细的控制和认证**，因为所有的TCP连接都必须经过应用网关进行处理和转发。
- <img src="./images/image-20230526143242050.png" alt="image-20230526143242050" style="zoom:50%;" />